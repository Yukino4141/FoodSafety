# **📘 食安卫士 (Food Safety) V2.0 详细接口开发文档**

**版本**: V2.0 (全量版)

**适用对象**: 后端开发、前端开发、测试人员

**文档状态**: 🟢 已确立

**最后更新**: 2025-12-26

---

## **📖 1\. 全局规范 (Global Standards)**

在开始写代码前，请务必阅读以下规范。

### **1.1 通信协议**

* **传输协议**: HTTP / HTTPS  
* **请求格式**: Content-Type: application/json (文件上传除外)  
* **响应格式**: Content-Type: application/json;charset=utf-8  
* **字符编码**: UTF-8

### **1.2 统一响应结构 (Result\<T\>)**

所有接口（无论成功失败）必须返回以下 JSON 结构。前端根据 code 判断业务状态。

JSON

{  
  "code": 1,           // 业务状态码。1: 成功; 0: 失败/业务错误  
  "msg": "操作成功",    // 提示信息。失败时显示具体错误原因（如"积分不足"）  
  "data": { ... }      // 业务数据泛型。如果没有数据，返回 null  
}

### **1.3 鉴权机制 (Authentication)**

* **技术选型**: JWT (JSON Web Token)  
* **Header**:  
  * **管理端**: 请求头必须携带 token: \<JWT字符串\>  
  * **C端用户**: 请求头必须携带 authentication: \<JWT字符串\>  
  * **例外**: 登录/注册接口无需携带。

### **1.4 核心枚举字典 (数据字典)**

变更说明: 风险等级不再仅依赖关键词，而是基于 AI 对配料表的健康打分 (0-100分)。
* **风险等级 (RiskLevel)**:  
  * 0: 低风险 / 安全 (Low/Safe)
    AI 打分区间: 80 - 100 分
    定义: 成分天然，无高风险添加剂，营养均衡。
  * 1: 中风险 (Medium) \- 
    AI 打分区间: 40 - 79 分
    定义: 含有一定量的糖分、盐分或普通食品添加剂，建议适量食用。
  * 2: 高风险 (High) \-
   AI 打分区间: 0 - 39 分

定义: 含有反式脂肪酸、致敏原、大量添加剂或营养价值极低。
* **库存状态 (InventoryStatus)**:  
  * 1: 正常 (Normal)  
  * 2: 临期 (Near Expiry) \- 距过期 \< 3天  
  * 3: 已过期 (Expired)  
  * 4: 已消耗 (Consumed)  
* **任务类型 (TaskType)** (用于积分):  
  * SCAN: 扫码 (+10分)  
  * POST: 发帖 (+50分)  
  * SHARE: 分享 (+20分)

---

## **📦 2\. C端用户模块 (App \- User)**

**功能描述**: 处理微信登录、个人信息及家庭成员管理。

### **2.1 微信登录**

* **接口地址**: /user/user/login  
* **请求方式**: POST  
* **无需鉴权**  
* **业务逻辑**:  
  1. 前端调用 wx.login() 获取 code。  
  2. 后端拿着 code 去找微信服务器换取 openid。  
  3. 查询数据库 user 表：  
     * 如果 openid 存在 \-\> 生成 JWT 令牌，登录成功。  
     * 如果 openid 不存在 \-\> 自动注册新用户，生成 JWT 令牌。  
  4. **V2.0新增逻辑**: 登录成功后，异步触发“库存检查任务”，如果有临期食品，准备好提示消息。

请求参数:

| 参数名 | 类型 | 必填 | 说明 | 示例 |

| :--- | :--- | :--- | :--- | :--- |

| code | string | 是 | 微信授权临时票据 | "081kL..." |

**响应数据 (UserLoginVO)**:

JSON

{  
  "code": 1,  
  "msg": "success",  
  "data": {  
    "id": 1001,  
    "openid": "wx\_oxCw...",  
    "token": "eyJhbGc..."  // 前端必须存储此Token  
  }  
}

### **2.2 获取当前用户画像**

* **接口地址**: /user/profile  
* **请求方式**: GET  
* **业务逻辑**: 查询 user\_profile 表。如果用户没填过，返回空对象或默认值。

**响应数据 (ProfileVO)**:

JSON

{  
  "code": 1,  
  "data": {  
    "allergens": \["花生", "芒果"\],   // 过敏原列表  
    "dietType": "低糖",             // 饮食偏好  
    "healthTags": \["糖尿病"\]        // 健康标签  
  }  
}

### **2.3 设置/更新用户画像**

* **接口地址**: /user/profile  
* **请求方式**: POST  
* **业务逻辑**: 这是一个 "Upsert" 操作（有则改之，无则加之）。保存到 user\_profile 表，JSON 字段需序列化存储。

请求参数 (ProfileDTO):

| 参数名 | 类型 | 必填 | 说明 |

| :--- | :--- | :--- | :--- |

| allergens | Array | 否 | 过敏原，如 \["海鲜"\] |

| dietType | string | 否 | 饮食偏好 |

| healthTags| Array | 否 | 慢性病，如 \["高血压"\] |

### **2.4 新增家庭成员 (V2.0)**

* **接口地址**: /user/family  
* **请求方式**: POST  
* **业务逻辑**: 在 family\_member 表新增一条记录，关联当前 user\_id。用于后续“切换视角”功能。

**请求参数 (FamilyMemberDTO)**:

JSON

{  
  "name": "宝宝",           // \[必填\] 昵称  
  "age": 5,                 // \[选填\] 年龄，用于AI分析判断  
  "healthTags": \["乳糖不耐受"\] // \[选填\] 特殊体质  
}

---

## **🛒 3\. 商品核心模块 (App \- Product)**

**功能描述**: 扫码、详情、搜索、收藏。这是 App 最核心的功能。

### **3.1 扫码获取商品详情 (⭐核心)**

* **接口地址**: /user/product/scan/{barcode}  
* **请求方式**: GET  
* **路径参数**: barcode (条形码，如 690123456789)  
* **业务逻辑 (复杂)**:  
  1. **查库**: 根据 barcode 查 product 表。  
     * 如果没有 \-\> 返回特定 Code (如 40401)，前端提示“库中暂无，请AI识别”。  
  2. **记录历史**: 插入一条记录到 scan\_history 表。  
  3. **触发积分**: 触发 AOP切面，调用 PointsService 给用户 \+10 积分（每天限10次）。  
  4. **个性化分析 (V2.0重点)**:  
     * 获取当前用户的画像（或当前选中的家庭成员画像）。  
     * 比对 product.json\_ingredients 和 profile.allergens。  
     * 如果配料包含过敏原（如“花生”），强制将返回数据的 safetyStatus 设为 RISK，并生成 riskMsg。  
  5. **查收藏**: 检查 product\_favorite 表，判断 isFavorite。

**响应数据 (ProductVO)**:

JSON

{  
  "code": 1,  
  "data": {  
    "id": 500,  
    "barcode": "690123456789",  
    "name": "全麦面包",  
    "image": "http://oss...",  
    "ingredientList": \["全麦粉", "水", "白砂糖", "花生碎"\], // 转为数组  
      
    // \--- V1.1 新增 \---  
    "nutritionInfo": {       // 营养成分Map  
        "能量": "1200kJ",  
        "蛋白质": "8.5g"  
    },  
      
    // \--- V1.2 新增 \---  
    "shelfLife": "15天",  
    "manufacturer": "桃李面包厂",  
      
    // \--- 个性化风险字段 \---  
    "safetyStatus": "RISK",  // "SAFE"(安全), "RISK"(有风险)  
    "riskLevel": 2,          // 0, 1, 2  
    "riskMsg": "警告：含有您设置的过敏原【花生】",   
      
    // \--- 互动字段 \---  
    "isFavorite": true       // true=已收藏  
  }  
}

### **3.2 商品收藏/取消**

* **接口地址**: /user/product/favorite  
* **请求方式**: POST  
* **业务逻辑**:  
  * 查询 product\_favorite 表。  
  * 如果已存在 \-\> 删除记录（取消收藏）。  
  * 如果不存 \-\> 插入记录（收藏成功）。  
* **请求参数**: {"productId": 500}  
* **响应数据**: data 返回 true (代表当前是收藏状态) 或 false (代表当前是未收藏)。

---

## **🥗 4\. 库存与保质期模块 (App \- Inventory)**

**功能描述**: 对应“我的冰箱”功能，管理食品保质期。

### **4.1 添加商品到库存**

* **接口地址**: /user/inventory  
* **请求方式**: POST  
* **业务逻辑**:  
  * 前端通常在“扫码详情页”点击“加入冰箱”。  
  * 后端计算：expiryDate (过期日)。如果前端没传过期日，尽量根据 product.shelf\_life 和 productionDate 估算（如果前端能提供生产日期）。如果都无法提供，默认设置为当前时间+保质期。  
  * 插入 product\_inventory 表。

**请求参数 (InventoryDTO)**:

JSON

{  
  "productId": 500,  
  "purchaseDate": "2025-12-26", // 购买日期  
  "expiryDate": "2026-01-10"    // \[必填\] 过期日期  
}

### **4.2 查询库存列表 (支持筛选)**

* **接口地址**: /user/inventory/list  
* **请求方式**: GET  
* **参数**: status (可选。1=查所有有效, 2=只查临期)  
* **业务逻辑**:  
  * 查询 product\_inventory 关联 product 表。  
  * **动态计算**: 遍历结果，计算 remainingDays \= expiryDate \- Today。  
  * 如果 remainingDays \< 0，后端需自动更新库里状态为“已过期”。  
  * 按 remainingDays 升序排序（快过期的排前面）。

**响应数据**:

JSON

{  
  "code": 1,  
  "data": \[  
    {  
      "id": 10,  
      "productName": "鲜牛奶",  
      "image": "...",  
      "expiryDate": "2025-12-28",  
      "remainingDays": 2,      // 重点字段：剩2天  
      "status": 2,             // 临期  
      "statusMsg": "请尽快食用"  
    }  
  \]  
}

---

## **💬 5\. 社区互动模块 (App \- Community)**

**功能描述**: V2.0 重点功能，类似“小红书”的帖子流。

### **5.1 发布帖子**

* **接口地址**: /user/community/post  
* **请求方式**: POST  
* **业务逻辑**:  
  1. 校验内容（敏感词过滤，建议使用 Hutool 的 SensitiveUtil 或调用阿里云文本审核API）。(这个功能暂定，有点困难，可放3.0，也就是先管理员人工审核）  
  2. 保存到 community\_post 表。  
  3. 触发积分奖励 (+50分)。  
* **请求参数 (PostDTO)**:

JSON

{  
  "title": "这个即食鸡胸肉太咸了！",  
  "content": "配料表里全是钠，避雷避雷...",  
  "images": \[  // 图片是上传到OSS后返回的URL  
     "https://oss.../1.jpg",   
     "https://oss.../2.jpg"  
  \]  
}

### **5.2 获取帖子列表 (分页)**

* **接口地址**: /user/community/feed  
* **请求方式**: GET  
* **参数**:  
  * page: 页码 (默认1)  
  * pageSize: 每页条数 (默认10)  
  * sort: latest (最新) / hot (最热/点赞最多)  
* **响应数据**: 返回标准的分页对象 PageResult\<PostVO\>。

### **5.3 点赞帖子**

* **接口地址**: /user/community/like  
* **请求方式**: POST  
* **参数**: {"postId": 100, "isLike": true}  
* **业务逻辑**:  
  * 修改 community\_post 的 like\_count 字段。  
  * (进阶) 在 Redis 中记录 User:Like:Post:100 防止重复点赞。(在我的设想中redis是如果最后有时间剩余可加，2.0版本暂不用）

---

## **🤖 6\. AI 工具模块 (App \- AI)**

**功能描述**: 封装 OCR 和 大模型分析接口。

### **6.1 上传配料表图片进行 OCR**

* **接口地址**: /user/ai/ocr  
* **请求方式**: POST  
* **Content-Type**: multipart/form-data  
* **参数**: file (二进制图片文件)  
* **业务逻辑**:  
  1. 将文件上传到阿里云 OSS，获取 url。  
  2. 调用 阿里云/百度 OCR API，识别图片文字。  
  3. **正则提取**: 在识别结果中寻找 "配料"、"成分" 等关键字，尝试提取配料子串。  
* **响应数据**:

JSON

{  
  "code": 1,  
  "data": {  
    "imageUrl": "http://oss...",  
    "rawText": "产品名称:XX... 配料: 小麦粉, 白砂糖, 植脂末...", // 完整OCR文本  
    "ingredients": \["小麦粉", "白砂糖", "植脂末"\] // 初步清洗后的数组  
  }  
}

### **6.2 AI 健康分析**

* **接口地址**: /user/ai/analyze  
* **请求方式**: POST  
* **说明**: 用户手动输入或 OCR 识别后的配料表分析。 
* **请求参数**:

JSON

{  
  "ingredients": \["植脂末", "代可可脂", "白砂糖"\],  
  "targetUser": "儿童" // 告诉AI是给谁吃的  
}

* **业务逻辑**:  
  1. 构造 Prompt: "请对以下配料表进行健康打分（0-100分）。规则：80-100为健康，40-80为中等，0-40为不健康。配料：[...]"

调用大模型: 获取分数和分析建议。

等级映射: 后端根据返回的分数设置 riskLevel。

Score >= 80 -> riskLevel = 0

40 <= Score < 80 -> riskLevel = 1

Score < 40 -> riskLevel = 2
* **响应数据**:

JSON

{  
  "code": 1,  
  "data": {  
    "score": 40,  
    "riskLevel": 2,  
    "summary": "极不推荐",  
    "suggestion": "含有大量反式脂肪酸来源，严重影响儿童发育..."  
  }  
}

---

## **💻 7\. 管理端模块 (Web \- Admin)**

**功能描述**: 给运营人员使用的后台。

### **7.1 新增商品 (入库)**

* **接口地址**: /admin/product  
* **请求方式**: POST  
* **说明**: 功能: 录入新商品，并自动进行 AI 定级。
* 业务逻辑 (Backend Logic):

接收前端提交的 jsonIngredients (配料表)。

同步/异步调用 AI 服务: 将配料表发送给大模型，要求打分 (0-100)。

自动定级:

如果 AI 评分 80-100: 设置 riskLevel = 0 (低风险)。

如果 AI 评分 40-79: 设置 riskLevel = 1 (中风险)。

如果 AI 评分 0-39: 设置 riskLevel = 2 (高风险)。

将计算出的 riskLevel 和 riskMsg (AI评价) 存入数据库 product 表。
* **请求参数**:

JSON

{  
  "barcode": "690...",  
  "name": "苏打水",  
  "jsonIngredients": "水,碳酸氢钠",  
  "riskLevel": 0,  
  "shelfLife": "12个月",      // V2.0 新增  
  "manufacturer": "某工厂",    // V2.0 新增  
  "ocrRawText": "OCR识别到的原始文本..." // V2.0 新增，留底备查  
}
响应数据:
{
  "code": 1,
  "msg": "录入成功，AI评分：65分，定级为中风险",
  "data": null
}

### **7.2 仪表盘数据**

* **接口地址**: /admin/dashboard  
* **请求方式**: GET  
* **响应数据**:

JSON

{  
  "totalUsers": 1205,      // 总用户数  
  "todayScans": 340,       // 今日扫码数  
  "pendingPosts": 12       // 待审核帖子数 (社区功能)  
}

---

## **📝 开发建议 **

**分包开发**:  
   * 先写 common 包的枚举和工具类。  
   * 再写 admin 端的商品录入（因为没有商品，C端没法扫码）。  
   * 接着写 app 端的扫码逻辑（最难的部分）。  
   * 最后写 community 和 ai 模块。  
 **调试工具**: 强烈建议使用 Apifox 或 Postman 进行接口测试，不要只靠前端联调。

